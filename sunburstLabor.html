<!DOCTYPE html>
  <head>
      <title>Sunburst for Women Labor Force in Punjab</title>
      <script src='https://d3js.org/d3.v4.min.js'></script>
      <script src='https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js'></script>
      <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
      <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.12/css/all.css" integrity="sha384-G0fIWCsCzJIMAVNQPfjH08cyYaUtMwjJwqiRKxxE/rx96Uroj1BtIQ6MLJuheaO9" crossorigin="anonymous">

      <!-- Want to run locally? Update src: 'https://d3js.org/d3.v4.min.js' -->
  </head>

  <style>
    body {
      background: white;
      font-family: 'Lato', sans-serif;
    }

    #trail {
      display:flex;
    }

    .labelContainer {
      max-width: 175px;
      min-width:  50px;
      height: 100%;
      padding: 8px;
      margin: 1px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 5px;
    }

    .fa-angle-right {
      color: white;
      font-size: 18px;
      margin-left: 4px;
    }

    #trailAndPercent {
      display: flex;
    }

    #endlabelDiv {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      padding: 8px;
      margin: 1px;
    }

    #endlabel {
      margin: 0px;
    }

    #sequence {
      width: 850px;
      height: 30px;
      display: flex;
    }

    #explanation {
      position: absolute;
      top: calc(50% - 45px);
      left: calc(50% - 130px);
      text-align: center;
      color: #212121;
      z-index: -1;
    }

    #chart {
      position: relative;
    }

    #main {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #percentage, #percentGlobal {
      font-size: 20px;
      font-weight: 450;
      color: #212121
    }

    .legendOrdinal text:not(.legendTitle) {
      font-size: 14px;
    }


  </style>

  <body>
    <div id="main">
      <div id="sequence"></div>
      <div id="NodeTypeDiv">
        <p id="NodeTypeText">

        </p>
      </div>
      <div id="chart">
        <div id="explanation" style="visibility: hidden; width: 260px">
          <span id="percentage"></span><br/>
          Denominator: Parent node<br/>
          <span id="percentGlobal"></span><br/>
          Denominator: All <span id="UrbRurTitle"></span><br/><br/>
        </div>
      </div>
    </div>
    <div id="sidebar">
    </div>
  </body>
  <script>
    const scalColCateg = d3.scaleOrdinal()
    let layerTypeScale
    d3.csv('laborHierarchy.csv', function(error, data){
      console.log(data);

      var seqValues = d3.nest()
                        .key(function(d) { return d.sequence; })
                        .rollup(function(v) { return d3.sum(v.map(d => d.weight)); })
                        .entries(data);

      console.log(seqValues);

      function convArrOfArr(dataset){
        let arrOfArr = dataset.map(d => {
          return [d.key, +d.value];
        })

        return arrOfArr;
      }

      // list of variables that are part of the sequence
      let seqVars = ["area", "laborForce", "employment", "industry", "barrier", "empType", "homeBased", "informal"]
      let layerTypes = ["Area", "Labor Force Participation", "Employment", "Industry", "Major barrier to work", "Employment Type", "Home based work", "Informal/ formal employment in non-agriculture sectors"];
      let idx = 0;

      let categs = [];
      let categLayerType = [];
      let setCategs;
      let arrCategs;
      seqVars.forEach(varble => {
        setCategs = new Set(data.map(d => d[varble]));
        arrCategs = Array.from(setCategs).filter(d => d!= "NA");

        categLayerType = categLayerType.concat(Array(arrCategs.length).fill(layerTypes[idx]));
        categs = categs.concat(arrCategs)
        idx += 1;
      })

      layerTypeScale = d3.scaleOrdinal()
                          .domain(categs)
                          .range(categLayerType);

      // declaring labels and colors
      let labels = ["Urban", "Rural", "Not in labor force", "Labor force"];
      let colors = ['#29B6F6','#4DB6AC','#FF8F00','#8E24AA'];


      // setting the domain and range of scale
      scalColCateg.domain(labels)
                  .range(colors);


      let arrOfArr = convArrOfArr(seqValues);
      console.log(convArrOfArr(seqValues));
      console.log(d3.sum(seqValues.map(d => d.value)));
      console.log(d3.sum(data.map(d => d.weight)));
      console.log(buildHierarchy(arrOfArr));
      let json = buildHierarchy(arrOfArr);
      createVisualization(json, scalColCateg);




    })


    // Dimensions of sunburst.
    var width = 850;
    var height = width/5 * 4;
    var radius = Math.min(width, height) / 2;

    // Breadcrumb dimensions: width, height, spacing, width of tip/tail.
    var b = {
      w: 100, h: 80, s: 5, t: 15
    };

    // Mapping of step names to colors.
    var colors = {
      "home": "#5687d1",
      "product": "#7b615c",
      "search": "#de783b",
      "account": "#6ab975",
      "other": "#a173d1",
      "end": "#bbbbbb"
    };

    // Total size of all segments; we set this later, after loading the data.
    var totalSize = 29020;

    var vis = d3.select("#chart").append("svg:svg")
        .attr("width", width)
        .attr("height", height)
        .append("svg:g")
        .attr("id", "container")
        .attr('mask', 'url(#gradientMask)')
        .style('mask', 'url(#gradientMask)')
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    var partition = d3.partition()
        .size([2 * Math.PI, radius * radius]);

    let offsetAngle = 0.5*Math.PI;

    var arc = d3.arc()
        .startAngle(function(d) { return d.x0 + offsetAngle; })
        .endAngle(function(d) { return d.x1 + offsetAngle; })
        .padAngle([0.0025])
        .innerRadius(function(d) { return Math.sqrt(d.y0); })
        .outerRadius(function(d) { return Math.sqrt(d.y1) - 2; });


    // Main function to draw and set up the visualization, once we have the data.
    function createVisualization(json, colScale) {

      // Basic setup of page elements.
      initializeBreadcrumbTrail();
      //drawLegend();
      d3.select("#togglelegend").on("click", toggleLegend);

      // Bounding circle underneath the sunburst, to make it easier to detect
      // when the mouse leaves the parent g.
      vis.append("svg:circle")
          .attr("r", radius)
          .style("opacity", 0);

      let radGradData = [{"offset": "40%", "stop-opacity": 1, "stop-color": "white"}, {"offset": "100%", "stop-opacity": .75, "stop-color": "white"}];

      d3.select('svg').append('defs')
          .append('radialGradient')
          .attr('id', 'radOpacGrad')
          .selectAll('stop')
          .data(radGradData)
          .enter()
          .append('stop')
          .attr('offset', d => d.offset)
          .attr('stop-opacity', d=> d[["stop-opacity"]])
          .attr('stop-color', d=> d[["stop-color"]]);

      d3.select('svg').select('defs')
          .append('mask')
          .attr('id', 'gradientMask')
          .append('g')
          .append('svg:circle')
          .attr('r', radius)
          //.style('fill', 'none')
          .style('fill', 'url(#radOpacGrad)');

      // Turn the data into a d3 hierarchy and calculate the sums.
      var root = d3.hierarchy(json)
          .sum(function(d) { return d.size; })
          .sort(function(a, b) { return b.value - a.value; });

      // For efficiency, filter nodes to keep only those large enough to see.
      var nodes = partition(root).descendants()
          .filter(function(d) {
              return (d.x1 - d.x0 > 0.005); // 0.005 radians = 0.29 degrees
          });

      console.log(nodes);

      var path = vis.data([json]).selectAll("path")
          .data(nodes)
          .enter().append("svg:path")
          .attr("display", function(d) { return d.depth ? null : "none"; })
          .attr("d", arc)
          .attr("fill-rule", "evenodd")
          .style("fill", function(d) {
            //console.log(d.data)
            //let datum = d
            //console.log(getParentCol(d))
            //console.log(scalColCateg(getParentCol(d)))
            return  scalColCateg(getParentCol(d))/*'#EEFF41' colScale(d.data.name);*/
          })
          .style("opacity", 1)
          .on("mouseover", mouseover);

      // Add the mouseleave handler to the bounding circle.
      d3.select("#container").on("mouseleave", mouseleave);

      // Get total size of the tree = value of root node from partition.
      totalSize = path.datum().value;

      // draw legend
      d3.select('svg').append("g")
        .attr("class", "legendOrdinal")
        .attr("transform", "translate(60 ,60)");

      var legendOrdinal = d3.legendColor()
        .shapePadding(2)
        .scale(scalColCateg)
        .cellFilter(function(d){ return d.label !== "root" });

      d3.select('svg').select(".legendOrdinal")
        .call(legendOrdinal);

      d3.select(".legendOrdinal").append('text')
        .classed('legendTitle', true)
        .text('Layer colors')
        .attr('transform', 'translate(0, -10)');

     };

    // Fade all but the current sequence, and show it in the breadcrumb trail.
    function mouseover(d) {

      var areaSize = getUrbRurWeight(d);
      let area = getUrbRurWeight(d).area;
      console.log(areaSize)
      var percentage = (100 * d.value / totalSize).toPrecision(3);
      var percArea = (100 * d.value / areaSize.weight).toPrecision(3);

      var parSize = d3.sum(d.parent.children.map(d => d.value));
      var percRelPar = (100 * d.value / parSize).toPrecision(3);

      var percentageString = percentage + "%";
      if (percentage < 0.1) {
        percentageString = "< 0.1%";
      }

      var percRelParString = percRelPar + "%";
      if (percRelPar < 1) {
        percRelPar = "< 0.1%";
      }


      d3.select("#percentage")
          .text(percRelParString);

      d3.select("#percentGlobal")
          .text(`${percArea}%`);

      d3.select("#UrbRurTitle")
          .text(area);

      d3.select("#explanation")
          .style("visibility", "");

      let hoveredName = d.data.name;

      d3.select("#NodeTypeText")
        .html(d => {
          return `<br>Layer Type: <span id ="NodeTypeTextSpan">${layerTypeScale(hoveredName)}</span>`
        })
        .style("opacity", 1);

      d3.select("#NodeTypeTextSpan").style('font-weight', 'bold');



      var sequenceArray = d.ancestors().reverse();
      sequenceArray.shift(); // remove root node from the array
      updateBreadcrumbs(sequenceArray, percentageString);

      // Fade all the segments.
      d3.selectAll("path")
          .style("opacity", 0.3);

      // Then highlight only those that are an ancestor of the current segment.
      vis.selectAll("path")
          .filter(function(node) {
                    return (sequenceArray.indexOf(node) >= 0);
                  })
          .style("opacity", 1);
    }

    // Restore everything to full opacity when moving off the visualization.
    function mouseleave(d) {

      // Hide the breadcrumb trail
      d3.select("#trail")
          .style("visibility", "hidden");

      // Deactivate all segments during transition.
      d3.selectAll("path").on("mouseover", null);

      // Transition each segment to full opacity and then reactivate it.
      d3.selectAll("path")
          .transition()
          .duration(1000)
          .style("opacity", 1)
          .on("end", function() {
                  d3.select(this).on("mouseover", mouseover);
                });

      d3.select("#explanation")
          .style("visibility", "hidden");

      d3.select("#NodeTypeText")
          .style("opacity", 0);

      d3.select("#endlabel")
          .style("opacity", 0);
    }

    function initializeBreadcrumbTrail() {
      // Add the svg area.
      var trailAndPercent = d3.select("#sequence").append("div")
          .style("width", '100%')
          .attr("id", "trailAndPercent");
      // Add the label at the end, for the percentage.
      trailAndPercent.append('div')
                    .attr('id', 'trail')
      trailAndPercent.append('div')
            .attr('id', 'endlabelDiv')
            .append('p')
            .attr('id', 'endlabel')
            .style('color', 'black')
            // .html(function() {
            //   return '<p id="endlabel" style="color: black"></p>'
            // })
    }

    // Generate a string that describes the points of a breadcrumb polygon.
    function breadcrumbPoints(d, i) {
      var points = [];
      points.push("0,0");
      points.push(b.w + ",0");
      points.push(b.w + b.t + "," + (b.h / 2));
      points.push(b.w + "," + b.h);
      points.push("0," + b.h);
      if (i > 0) { // Leftmost breadcrumb; don't include 6th vertex.
        points.push(b.t + "," + (b.h / 2));
      }
      return points.join(" ");
    }

    // Update the breadcrumb trail to show the current sequence and percentage.
    function updateBreadcrumbs(nodeArray, percentageString) {

      // Data join; key function combines name and depth (= position in sequence).
      console.log("nodeArray", nodeArray)
      var trail = d3.select("#trail")
          .selectAll("div")
          .data(nodeArray, function(d) {
            console.log(d)
            return d.data.name + d.depth;
          });

      // Remove exiting nodes.
      trail.exit().remove();

      // Add breadcrumb and label for entering nodes.
      var entering = trail.enter().append("div").attr('class', 'labelContainer');

      entering.style('background', function(d) { return scalColCateg(getParentCol(d)); });

      entering.html(function(d) {
        return '<span style="color: white">' + d.data.name + ' </span><i class="fas fa-angle-right"></i>'
      });
        //  .attr("width", b.w)
        //  .attr("height", b.h)
        //  .style("fill", function(d) { return scalColCateg(getParentCol(d)); });

      entering.append("svg:text")
          .attr("x", b.w/2)
          .attr("y", b.h / 4)
          .attr("dy", "0.35em")
          //.attr("dx", "0.35em")
          //.attr("text-anchor", "middle")
          .text(function(d) { return d.data.name; })
          //.call(wrap, b.w)

      //entering.selectAll('text').call(wrap, b.w);

      // Merge enter and update selections; set position for all nodes.
      entering.merge(trail).attr("transform", function(d, i) {
        return "translate(" + i * (b.w + b.s) + ", 0)";
      });

      // Now move and update the percentage at the end.
      d3.select("#trailAndPercent").select("#endlabel")
          .attr("x", (nodeArray.length + 0.5) * (b.w + b.s))
          .attr("y", b.h / 2)
          .attr("dy", "0.35em")
          .attr("text-anchor", "middle")
          .style('opacity', 1)
          .text(percentageString + " (Punjab)");

      // Make the breadcrumb trail visible, if it's hidden.
      d3.select("#trail")
          .style("visibility", "");

    }

    function drawLegend() {

      // Dimensions of legend item: width, height, spacing, radius of rounded rect.
      var li = {
        w: 75, h: 30, s: 3, r: 3
      };

      var legend = d3.select("#legend").append("svg:svg")
          .attr("width", li.w)
          .attr("height", d3.keys(colors).length * (li.h + li.s));

      var g = legend.selectAll("g")
          .data(d3.entries(colors))
          .enter().append("svg:g")
          .attr("transform", function(d, i) {
                  return "translate(0," + i * (li.h + li.s) + ")";
               });

      g.append("svg:rect")
          .attr("rx", li.r)
          .attr("ry", li.r)
          .attr("width", li.w)
          .attr("height", li.h)
          .style("fill", function(d) { return d.value; });

      g.append("svg:text")
          .attr("x", li.w / 2)
          .attr("y", li.h / 2)
          .attr("dy", "0.35em")
          .attr("text-anchor", "middle")
          .text(function(d) { return d.key; });
    }

    function toggleLegend() {
      var legend = d3.select("#legend");
      if (legend.style("visibility") == "hidden") {
        legend.style("visibility", "");
      } else {
        legend.style("visibility", "hidden");
      }
    }

    // Take a 2-column CSV and transform it into a hierarchical structure suitable
    // for a partition layout. The first column is a sequence of step names, from
    // root to leaf, separated by hyphens. The second column is a count of how
    // often that sequence occurred.
    function buildHierarchy(csv) {
      var root = {"name": "root", "children": []};
      for (var i = 0; i < csv.length; i++) {
        var sequence = csv[i][0];
        var size = +csv[i][1];
        // console.log(csv[0])
        // console.log("i", i);
        // console.log("sequence", sequence)
        // console.log("size", size)
        if (isNaN(size)) { // e.g. if this is a header row
          continue;
        }
        var parts = sequence.split("-");
        // console.log("parts", parts)
        var currentNode = root;
        for (var j = 0; j < parts.length; j++) {
          var children = currentNode["children"];
          // console.log("j", j)
          //console.log("children", children)
          // console.log("nodeName", nodeName)
          var nodeName = parts[j];
          var childNode;
          if (j + 1 < parts.length) {
            // Not yet at the end of the sequence; move down the tree.
     	      var foundChild = false;
     	      for (var k = 0; k < children.length; k++) {
              // console.log("k", k);
     	        if (children[k]["name"] == nodeName) {
     	          childNode = children[k];
     	          foundChild = true;
     	          break;
     	        }
     	      }
            // If we don't already have a child node for this branch, create it.
          	if (!foundChild) {
          	  childNode = {"name": nodeName, "children": []};
          	  children.push(childNode);
          	}
            // console.log("foundChild", foundChild);
            // console.log("childNode", childNode);
            // console.log("children", children);
       	    currentNode = childNode;
          } else {
           	// Reached the end of the sequence; create a leaf node.
           	childNode = {"name": nodeName, "size": size};
           	children.push(childNode);
            // console.log("childNode", childNode);
            // console.log("children", children);
          }
        }
        // console.log(root)
      }

      return root;
    };



    function getParentCol(datum){
      let coloredCategs = ["Urban", "Rural", "Not in labor force", "Labor force", "root"];
      //console.log(datum);
      //console.log(datum.data.name);
      //console.log(datum.data.name)
      //console.log(coloredCategs.includes(datum.data.name))
      if (coloredCategs.includes(datum.data.name)){
        return datum.data.name;
      }
      else {
        return getParentCol(datum.parent);
      }
    }

    function getUrbRurWeight(datum){
      let categs = ["Urban", "Rural"];
      //console.log(datum);
      //console.log(datum.data.name);
      //console.log(datum.data.name)
      //console.log(coloredCategs.includes(datum.data.name))
      if (categs.includes(datum.data.name)){
        return {
          area: datum.data.name,
          weight: datum.value
        };
      }
      else {
        return getUrbRurWeight(datum.parent);
      }
    }


  </script>
